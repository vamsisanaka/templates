# Complete Function App Pipeline Template
# Supports multiple .NET versions (2.1.x, 3.1.x, 6.x, 8.x)
# Includes: Build, Test, SonarQube, Publish stages

parameters:
  - name: workingDirectory
    type: string
  - name: projectFile
    type: string
  - name: dotnetVersion
    type: string
    default: '8.x'
  - name: sonarQubeEnabled
    type: boolean
    default: false
  - name: sonarProjectKey
    type: string
    default: ''
  - name: sonarConnectionName
    type: string
    default: 'SonarQube'
  - name: runTests
    type: boolean
    default: true
  - name: artifactName
    type: string
    default: 'functionapp'
  - name: buildConfiguration
    type: string
    default: 'Debug'
  - name: nugetFeedUrl
    type: string
    default: ''
  - name: agentPool
    type: string
    default: 'ubuntu-latest'

jobs:
  - job: FunctionAppBuild
    displayName: 'Function App Build'
    pool:
      vmImage: ${{ parameters.agentPool }}
   
    steps:
      # Setup .NET SDK based on version
      - task: UseDotNet@2
        displayName: 'Use .NET Core SDK ${{ parameters.dotnetVersion }}'
        inputs:
          packageType: 'sdk'
          version: '${{ parameters.dotnetVersion }}'

      # SonarQube Prepare
      - ${{ if eq(parameters.sonarQubeEnabled, true) }}:
        - task: SonarQubePrepare@5
          displayName: 'Prepare SonarQube Analysis'
          condition: eq(variables['sonarqube.enableScan'], 'true')
          inputs:
            SonarQube: '${{ parameters.sonarConnectionName }}'
            scannerMode: 'MSBuild'
            projectKey: '${{ parameters.sonarProjectKey }}'
     
      # DotNet Clean
      - task: DotNetCoreCLI@2
        displayName: 'Dotnet Clean'
        inputs:
          command: 'custom'
          custom: 'clean'
          projects: '${{ parameters.workingDirectory }}/${{ parameters.projectFile }}'
          arguments: '-c ${{ parameters.buildConfiguration }}'
     
      # DotNet Restore
      - task: DotNetCoreCLI@2
        displayName: 'Dotnet Restore'
        inputs:
          command: 'restore'
          projects: '${{ parameters.workingDirectory }}/${{ parameters.projectFile }}'
          feedsToUse: 'select'
          includeNuGetOrg: true
          ${{ if ne(parameters.nugetFeedUrl, '') }}:
            vstsFeed: '${{ parameters.nugetFeedUrl }}'
     
      # DotNet Build
      - task: DotNetCoreCLI@2
        displayName: 'Dotnet Build'
        inputs:
          command: 'build'
          projects: '${{ parameters.workingDirectory }}/${{ parameters.projectFile }}'
          arguments: '-c ${{ parameters.buildConfiguration }} --no-restore'

      # DotNet Test
      - ${{ if eq(parameters.runTests, true) }}:
        - task: DotNetCoreCLI@2
          displayName: 'Dotnet Test'
          condition: and(succeeded(), or(eq(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
          inputs:
            command: 'test'
            projects: '${{ parameters.workingDirectory }}'
            arguments: '--configuration ${{ parameters.buildConfiguration }} /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura --no-build'
            testRunTitle: '$(Build.DefinitionName) - Unit Test'

      # SonarQube Analyze
      - ${{ if eq(parameters.sonarQubeEnabled, true) }}:
        - task: SonarQubeAnalyze@5
          displayName: 'Run SonarQube Analysis'
          condition: and(succeeded(), eq(variables['sonarqube.enableScan'], 'true'))

      # SonarQube Quality Gate
      - ${{ if eq(parameters.sonarQubeEnabled, true) }}:
        - task: SonarQubePublish@5
          displayName: 'Publish SonarQube Quality Gate Result'
          condition: and(succeeded(), eq(variables['sonarqube.enableScan'], 'true'))
          inputs:
            pollingTimeoutSec: '300'

      # DotNet Publish
      - task: DotNetCoreCLI@2
        displayName: 'Dotnet Publish'
        inputs:
          command: 'publish'
          publishWebProjects: false
          projects: '${{ parameters.workingDirectory }}/**/*.csproj'
          arguments: '-c ${{ parameters.buildConfiguration }} -o $(Build.ArtifactStagingDirectory)/functionapp --no-build'
          zipAfterPublish: false
          modifyOutputPath: false
          workingDirectory: '${{ parameters.workingDirectory }}'

      # Working Dir Output - function.json
      - task: Bash@3
        displayName: 'Working Dir Output - function.json'
        inputs:
          targetType: 'inline'
          script: |
            echo "******************** LOOKING FOR function.json FILES in WorkingDir ********************************"
            find . -name function.json
          workingDirectory: '${{ parameters.workingDirectory }}'

      # Copy functionapp.json to staging
      - task: Bash@3
        displayName: 'Copy functionapp.json to staging'
        inputs:
          targetType: 'inline'
          script: |
            cd ${{ parameters.workingDirectory }}
            echo "******************** COPYING function.json FILES to ArtifactStagingDirectory ******************"
            for i in $(find . -name function.json -exec dirname {} \;)
            do
              cp -nr $i $(Build.ArtifactStagingDirectory)/functionapp
            done

      # Staging Dir Output - function.json
      - task: Bash@3
        displayName: 'Staging Dir Output - function.json'
        inputs:
          targetType: 'inline'
          script: |
            echo "******************** LOOKING FOR function.json FILES in ArtifactStagingDirectory ******************"
            find . -name function.json
          workingDirectory: '$(Build.ArtifactStagingDirectory)/functionapp'

      # Archive Files
      - task: ArchiveFiles@2
        displayName: 'Archive files'
        inputs:
          rootFolderOrFile: '$(Build.ArtifactStagingDirectory)/functionapp'
          includeRootFolder: false
          archiveType: 'zip'
          archiveFile: '$(Build.ArtifactStagingDirectory)/functionapp.zip'
          replaceExistingArchive: true

      # Publish Build Artifacts
      - task: PublishBuildArtifacts@1
        displayName: 'Publish Build Artifacts'
        condition: and(succeeded(), ne(variables['Build.Reason'], 'PullRequest'))
        inputs:
          PathtoPublish: '$(Build.ArtifactStagingDirectory)/functionapp.zip'
          ArtifactName: '${{ parameters.artifactName }}'
          publishLocation: 'Container'